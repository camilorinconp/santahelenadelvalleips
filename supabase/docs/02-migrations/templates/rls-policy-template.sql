-- =============================================
-- TEMPLATE: ROW LEVEL SECURITY (RLS) POLICIES
-- =============================================
-- Descripci√≥n: Template reutilizable para configurar RLS siguiendo
--              convenciones de seguridad IPS Santa Helena del Valle
-- Fecha: [DD mes AAAA]
-- Autor: [Tu nombre]
-- Contexto: [Explicar modelo de seguridad requerido]
-- Impacto: [Describir qu√© acceso se permite/bloquea]
-- =============================================

BEGIN;

-- =============================================
-- 1. VERIFICACIONES PRE-EJECUCI√ìN
-- =============================================
DO $pre_check$
DECLARE
    table_exists BOOLEAN;
    rls_enabled BOOLEAN;
    existing_policies INTEGER;
BEGIN
    -- Verificar que la tabla existe
    SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = '[NOMBRE_TABLA]'
    ) INTO table_exists;
    
    IF NOT table_exists THEN
        RAISE EXCEPTION 'Tabla [NOMBRE_TABLA] no existe. Crear tabla primero.';
    END IF;
    
    -- Verificar estado RLS actual
    SELECT EXISTS (
        SELECT FROM pg_class c
        JOIN pg_namespace n ON n.oid = c.relnamespace
        WHERE n.nspname = 'public'
        AND c.relname = '[NOMBRE_TABLA]'
        AND c.relrowsecurity = true
    ) INTO rls_enabled;
    
    -- Contar pol√≠ticas existentes
    SELECT COUNT(*) INTO existing_policies
    FROM pg_policies 
    WHERE tablename = '[NOMBRE_TABLA]' 
    AND schemaname = 'public';
    
    RAISE NOTICE 'üîí Configurando RLS para tabla: [NOMBRE_TABLA]';
    RAISE NOTICE 'RLS actualmente habilitado: %', rls_enabled;
    RAISE NOTICE 'Pol√≠ticas existentes: %', existing_policies;
END;
$pre_check$;

-- =============================================
-- 2. HABILITAR RLS EN LA TABLA
-- =============================================

-- Habilitar Row Level Security
ALTER TABLE [NOMBRE_TABLA] ENABLE ROW LEVEL SECURITY;

-- =============================================
-- 3. POL√çTICA PRINCIPAL: SERVICE_ROLE (BACKEND)
-- =============================================
-- CR√çTICO: Backend FastAPI debe tener acceso completo

-- Eliminar policy existente si existe
DROP POLICY IF EXISTS "service_role_full_access_[NOMBRE_TABLA]" ON [NOMBRE_TABLA];

-- Crear policy completa para service_role
CREATE POLICY "service_role_full_access_[NOMBRE_TABLA]" ON [NOMBRE_TABLA]
FOR ALL 
TO service_role
USING (true)           -- Puede leer cualquier registro
WITH CHECK (true);     -- Puede insertar/actualizar cualquier registro

-- =============================================
-- 4. POL√çTICAS PARA AUTHENTICATED USERS
-- =============================================

-- OPCI√ìN A: Acceso completo de lectura
-- Usar para cat√°logos, lookups, datos p√∫blicos
DROP POLICY IF EXISTS "authenticated_read_all_[NOMBRE_TABLA]" ON [NOMBRE_TABLA];

CREATE POLICY "authenticated_read_all_[NOMBRE_TABLA]" ON [NOMBRE_TABLA]
FOR SELECT 
TO authenticated
USING (true);  -- Todos los registros visibles

-- OPCI√ìN B: Acceso filtrado por condici√≥n business
-- Usar para datos sensibles con reglas espec√≠ficas
-- DROP POLICY IF EXISTS "authenticated_read_filtered_[NOMBRE_TABLA]" ON [NOMBRE_TABLA];

-- CREATE POLICY "authenticated_read_filtered_[NOMBRE_TABLA]" ON [NOMBRE_TABLA]
-- FOR SELECT 
-- TO authenticated
-- USING (
--     -- Solo registros activos
--     estado_activo = true 
--     -- O solo registros del usuario actual
--     -- OR creado_por = auth.uid()
--     -- O solo registros p√∫blicos
--     -- OR visibilidad = 'publico'
-- );

-- OPCI√ìN C: Acceso basado en roles de usuario
-- Requiere tabla usuarios con roles
-- DROP POLICY IF EXISTS "authenticated_role_based_[NOMBRE_TABLA]" ON [NOMBRE_TABLA];

-- CREATE POLICY "authenticated_role_based_[NOMBRE_TABLA]" ON [NOMBRE_TABLA]
-- FOR SELECT 
-- TO authenticated
-- USING (
--     EXISTS (
--         SELECT 1 FROM usuarios u
--         WHERE u.id = auth.uid()
--         AND u.rol IN ('admin', 'medico', 'enfermero')
--     )
--     -- Adem√°s de condiciones espec√≠ficas del registro
--     AND estado_activo = true
-- );

-- =============================================
-- 5. POL√çTICAS PARA INSERCI√ìN (AUTHENTICATED)
-- =============================================

-- OPCI√ìN A: Inserci√≥n libre (para cat√°logos, logs)
-- DROP POLICY IF EXISTS "authenticated_insert_[NOMBRE_TABLA]" ON [NOMBRE_TABLA];

-- CREATE POLICY "authenticated_insert_[NOMBRE_TABLA]" ON [NOMBRE_TABLA]
-- FOR INSERT 
-- TO authenticated
-- WITH CHECK (true);

-- OPCI√ìN B: Inserci√≥n con validaciones business
DROP POLICY IF EXISTS "authenticated_insert_validated_[NOMBRE_TABLA]" ON [NOMBRE_TABLA];

CREATE POLICY "authenticated_insert_validated_[NOMBRE_TABLA]" ON [NOMBRE_TABLA]
FOR INSERT 
TO authenticated
WITH CHECK (
    -- Solo puede insertar si es usuario v√°lido
    auth.uid() IS NOT NULL
    -- Y cumple condiciones espec√≠ficas
    -- AND campo_requerido IS NOT NULL
    -- AND campo_requerido != ''
);

-- =============================================
-- 6. POL√çTICAS PARA ACTUALIZACI√ìN (AUTHENTICATED)
-- =============================================

-- OPCI√ìN A: Actualizaci√≥n propia (usuario solo sus registros)
-- DROP POLICY IF EXISTS "authenticated_update_own_[NOMBRE_TABLA]" ON [NOMBRE_TABLA];

-- CREATE POLICY "authenticated_update_own_[NOMBRE_TABLA]" ON [NOMBRE_TABLA]
-- FOR UPDATE 
-- TO authenticated
-- USING (creado_por = auth.uid())           -- Solo los que cre√≥
-- WITH CHECK (actualizado_por = auth.uid()); -- Solo puede poner su ID

-- OPCI√ìN B: Actualizaci√≥n con validaciones business
DROP POLICY IF EXISTS "authenticated_update_validated_[NOMBRE_TABLA]" ON [NOMBRE_TABLA];

CREATE POLICY "authenticated_update_validated_[NOMBRE_TABLA]" ON [NOMBRE_TABLA]
FOR UPDATE 
TO authenticated
USING (
    -- Puede actualizar registros activos
    estado_activo = true
    -- Y que no est√©n bloqueados
    -- AND bloqueado_para_edicion = false
    -- O que sean suyos
    -- OR creado_por = auth.uid()
)
WITH CHECK (
    -- Las actualizaciones deben mantener integridad
    auth.uid() IS NOT NULL
    -- Y no pueden cambiar campos cr√≠ticos (ejemplo)
    -- AND codigo_inmutable = codigo_inmutable  -- Evita cambio
);

-- =============================================
-- 7. POL√çTICAS PARA ELIMINACI√ìN (AUTHENTICATED)
-- =============================================

-- OPCI√ìN A: Solo soft delete (recomendado para datos cr√≠ticos)
DROP POLICY IF EXISTS "authenticated_soft_delete_[NOMBRE_TABLA]" ON [NOMBRE_TABLA];

CREATE POLICY "authenticated_soft_delete_[NOMBRE_TABLA]" ON [NOMBRE_TABLA]
FOR UPDATE 
TO authenticated
USING (
    -- Solo puede "eliminar" (marcar inactivo) registros activos
    estado_activo = true
    AND creado_por = auth.uid()
)
WITH CHECK (
    -- La "eliminaci√≥n" es cambiar estado
    estado_activo = false
    AND actualizado_por = auth.uid()
);

-- OPCI√ìN B: Eliminaci√≥n f√≠sica (CUIDADO - solo para datos no cr√≠ticos)
-- DROP POLICY IF EXISTS "authenticated_delete_[NOMBRE_TABLA]" ON [NOMBRE_TABLA];

-- CREATE POLICY "authenticated_delete_[NOMBRE_TABLA]" ON [NOMBRE_TABLA]
-- FOR DELETE 
-- TO authenticated
-- USING (
--     -- Solo puede eliminar registros propios
--     creado_por = auth.uid()
--     -- Y que no est√©n referenciados
--     AND NOT EXISTS (SELECT 1 FROM tabla_dependiente WHERE fk_id = id)
-- );

-- =============================================
-- 8. POL√çTICAS PARA ANONYMOUS USERS
-- =============================================

-- OPCI√ìN A: Sin acceso (m√°s seguro - recomendado para datos sensibles)
-- No crear pol√≠ticas para anon = sin acceso

-- OPCI√ìN B: Solo lectura muy limitada (para datos p√∫blicos)
-- DROP POLICY IF EXISTS "anon_read_public_[NOMBRE_TABLA]" ON [NOMBRE_TABLA];

-- CREATE POLICY "anon_read_public_[NOMBRE_TABLA]" ON [NOMBRE_TABLA]
-- FOR SELECT 
-- TO anon
-- USING (
--     -- Solo registros marcados como p√∫blicos
--     visibilidad_publica = true
--     AND estado_activo = true
--     -- Con datos no sensibles √∫nicamente
-- );

-- =============================================
-- 9. GRANTS EXPL√çCITOS (COMPLEMENTA RLS)
-- =============================================

-- Service role necesita grants expl√≠citos adem√°s de policies
GRANT ALL ON [NOMBRE_TABLA] TO service_role;
GRANT ALL ON [NOMBRE_TABLA] TO postgres;

-- Authenticated users - grants seg√∫n necesidad
GRANT SELECT ON [NOMBRE_TABLA] TO authenticated;
GRANT INSERT ON [NOMBRE_TABLA] TO authenticated;
GRANT UPDATE ON [NOMBRE_TABLA] TO authenticated;
-- GRANT DELETE ON [NOMBRE_TABLA] TO authenticated; -- Solo si permite eliminaci√≥n f√≠sica

-- Anonymous - grants m√≠nimos (solo si hay policy anon)
-- GRANT SELECT ON [NOMBRE_TABLA] TO anon;

-- =============================================
-- 10. POL√çTICAS ESPECIALES POR CONTEXTO
-- =============================================

-- CONTEXTO M√âDICO: Acceso basado en especialidad
-- CREATE POLICY "medico_specialty_access_[NOMBRE_TABLA]" ON [NOMBRE_TABLA]
-- FOR SELECT 
-- TO authenticated
-- USING (
--     EXISTS (
--         SELECT 1 FROM medicos m
--         WHERE m.usuario_id = auth.uid()
--         AND (
--             m.especialidad = 'general'  -- M√©dico general ve todo
--             OR m.especialidad = especialidad_requerida  -- Especialista ve su √°rea
--         )
--     )
-- );

-- CONTEXTO COMPLIANCE: Acceso solo a datos propios centro m√©dico
-- CREATE POLICY "center_based_access_[NOMBRE_TABLA]" ON [NOMBRE_TABLA]
-- FOR ALL
-- TO authenticated
-- USING (
--     centro_medico_id IN (
--         SELECT centro_id FROM usuarios_centros 
--         WHERE usuario_id = auth.uid()
--     )
-- )
-- WITH CHECK (
--     centro_medico_id IN (
--         SELECT centro_id FROM usuarios_centros 
--         WHERE usuario_id = auth.uid()
--     )
-- );

-- CONTEXTO PACIENTES: Solo acceso a sus propios datos
-- CREATE POLICY "patient_own_data_[NOMBRE_TABLA]" ON [NOMBRE_TABLA]
-- FOR SELECT
-- TO authenticated
-- USING (
--     -- Paciente ve solo sus datos
--     paciente_id = (
--         SELECT p.id FROM pacientes p 
--         WHERE p.usuario_id = auth.uid()
--     )
--     -- O m√©dico ve pacientes asignados
--     OR EXISTS (
--         SELECT 1 FROM medico_paciente_asignacion mpa
--         WHERE mpa.paciente_id = paciente_id
--         AND mpa.medico_id = (
--             SELECT m.id FROM medicos m 
--             WHERE m.usuario_id = auth.uid()
--         )
--     )
-- );

-- =============================================
-- 11. VERIFICACIONES POST-EJECUCI√ìN
-- =============================================

DO $verification$
DECLARE
    rls_enabled BOOLEAN;
    policy_count INTEGER;
    service_role_policies INTEGER;
    authenticated_policies INTEGER;
    anon_policies INTEGER;
BEGIN
    -- Verificar RLS habilitado
    SELECT EXISTS (
        SELECT FROM pg_class c
        JOIN pg_namespace n ON n.oid = c.relnamespace
        WHERE n.nspname = 'public'
        AND c.relname = '[NOMBRE_TABLA]'
        AND c.relrowsecurity = true
    ) INTO rls_enabled;
    
    -- Contar pol√≠ticas por rol
    SELECT COUNT(*) INTO policy_count
    FROM pg_policies 
    WHERE tablename = '[NOMBRE_TABLA]' AND schemaname = 'public';
    
    SELECT COUNT(*) INTO service_role_policies
    FROM pg_policies 
    WHERE tablename = '[NOMBRE_TABLA]' AND schemaname = 'public'
    AND 'service_role' = ANY(roles);
    
    SELECT COUNT(*) INTO authenticated_policies
    FROM pg_policies 
    WHERE tablename = '[NOMBRE_TABLA]' AND schemaname = 'public'
    AND 'authenticated' = ANY(roles);
    
    SELECT COUNT(*) INTO anon_policies
    FROM pg_policies 
    WHERE tablename = '[NOMBRE_TABLA]' AND schemaname = 'public'
    AND 'anon' = ANY(roles);
    
    -- Log resultados verificaci√≥n
    RAISE NOTICE '=== VERIFICACI√ìN RLS [NOMBRE_TABLA] ===';
    RAISE NOTICE 'RLS habilitado: %', rls_enabled;
    RAISE NOTICE 'Total pol√≠ticas: %', policy_count;
    RAISE NOTICE 'Pol√≠ticas service_role: % (esperado: ‚â•1)', service_role_policies;
    RAISE NOTICE 'Pol√≠ticas authenticated: %', authenticated_policies;
    RAISE NOTICE 'Pol√≠ticas anonymous: %', anon_policies;
    
    -- Test b√°sico de acceso (simulado)
    RAISE NOTICE 'üß™ Testing policy access...';
    
    -- Validaci√≥n final
    IF rls_enabled AND service_role_policies >= 1 THEN
        RAISE NOTICE '‚úÖ SUCCESS: RLS configurado correctamente';
        RAISE NOTICE 'Backend access: GARANTIZADO (service_role)';
        
        IF authenticated_policies > 0 THEN
            RAISE NOTICE 'User access: CONFIGURADO (authenticated)';
        ELSE
            RAISE NOTICE 'User access: BLOQUEADO (sin policies authenticated)';
        END IF;
        
        IF anon_policies > 0 THEN
            RAISE NOTICE 'Anonymous access: PERMITIDO (‚ö†Ô∏è  verificar si es intencional)';
        ELSE
            RAISE NOTICE 'Anonymous access: BLOQUEADO (recomendado)';
        END IF;
    ELSE
        RAISE EXCEPTION '‚ùå ERROR: RLS configuraci√≥n incompleta';
    END IF;
    
    RAISE NOTICE '==========================================';
END;
$verification$;

COMMIT;

-- =============================================
-- NOTAS DE USO DEL TEMPLATE
-- =============================================
/*
INSTRUCCIONES DE USO:

1. REEMPLAZAR PLACEHOLDERS:
   - [NOMBRE_TABLA]: Tabla donde aplicar RLS
   - [DD mes AAAA]: Fecha actual
   - [Tu nombre]: Tu nombre o equipo

2. SELECCIONAR OPCIONES SEG√öN CONTEXTO:
   - Uncomment las pol√≠ticas que apliquen a tu caso
   - Personalizar condiciones USING y WITH CHECK
   - Ajustar roles seg√∫n modelo de seguridad

3. MODELOS DE SEGURIDAD T√çPICOS:

   P√öBLICO (CAT√ÅLOGOS):
   - Service role: acceso completo
   - Authenticated: lectura completa
   - Anonymous: lectura limitada o bloqueado

   SENSIBLE (PACIENTES):
   - Service role: acceso completo
   - Authenticated: solo datos propios o asignados
   - Anonymous: bloqueado completo

   OPERACIONAL (LOGS, AUDITOR√çA):
   - Service role: acceso completo
   - Authenticated: solo inserci√≥n/lectura propia
   - Anonymous: bloqueado completo

4. TESTING DE POL√çTICAS:
   -- En psql:
   SET ROLE service_role;
   SELECT COUNT(*) FROM [NOMBRE_TABLA];  -- Debe funcionar

   SET ROLE authenticated;  
   SELECT COUNT(*) FROM [NOMBRE_TABLA];  -- Seg√∫n policy

   SET ROLE anon;
   SELECT COUNT(*) FROM [NOMBRE_TABLA];  -- Seg√∫n policy

5. CONSIDERACIONES PERFORMANCE:
   - Pol√≠ticas complejas pueden impactar performance
   - Usar √≠ndices en columnas referenciadas en policies
   - Evitar subconsultas costosas en USING/WITH CHECK
   - Test performance con datos reales

6. DEBUGGING POL√çTICAS:
   -- Ver pol√≠ticas aplicadas:
   SELECT schemaname, tablename, policyname, cmd, roles, qual, with_check
   FROM pg_policies 
   WHERE tablename = '[NOMBRE_TABLA]';

   -- Test espec√≠fico de policy:
   EXPLAIN (ANALYZE, BUFFERS) 
   SELECT * FROM [NOMBRE_TABLA] LIMIT 10;

7. PATRONES COMUNES:

   OWNERSHIP (creado_por):
   USING (creado_por = auth.uid())

   ROLE-BASED:
   USING (EXISTS (SELECT 1 FROM usuarios WHERE id = auth.uid() AND rol = 'admin'))

   CENTER/ORGANIZATION:
   USING (centro_id IN (SELECT centro_id FROM user_centers WHERE user_id = auth.uid()))

   TIME-BASED:
   USING (fecha_vigencia >= NOW() AND fecha_vencimiento <= NOW())

   STATUS-BASED:
   USING (activo = true AND aprobado = true)

   HIERARCHICAL:
   USING (nivel_acceso <= (SELECT nivel FROM usuarios WHERE id = auth.uid()))

8. ERRORES COMUNES A EVITAR:
   - Olvidar policy para service_role (backend falla)
   - Policies muy restrictivas (usuarios no pueden trabajar)
   - Policies muy permisivas (riesgo seguridad)
   - No considerar performance de subconsultas
   - Inconsistencia entre USING y WITH CHECK

9. BACKUP ANTES DE APLICAR:
   -- Backup pol√≠ticas existentes:
   pg_dump --schema-only --table=[NOMBRE_TABLA] database > rls_backup.sql
*/